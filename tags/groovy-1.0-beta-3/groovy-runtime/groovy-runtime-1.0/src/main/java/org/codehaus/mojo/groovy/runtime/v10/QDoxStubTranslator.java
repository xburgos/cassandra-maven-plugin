/*
 * Copyright (C) 2006-2007 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.codehaus.mojo.groovy.runtime.v10;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.thoughtworks.qdox.JavaDocBuilder;
import com.thoughtworks.qdox.model.AbstractJavaEntity;
import com.thoughtworks.qdox.model.DefaultDocletTag;
import com.thoughtworks.qdox.model.DocletTag;
import com.thoughtworks.qdox.model.JavaClass;
import com.thoughtworks.qdox.model.JavaField;
import com.thoughtworks.qdox.model.JavaMethod;
import com.thoughtworks.qdox.model.JavaParameter;
import com.thoughtworks.qdox.model.JavaSource;
import com.thoughtworks.qdox.model.Type;
import groovyjarjarantlr.collections.AST;
import org.codehaus.groovy.antlr.ASTRuntimeException;
import org.codehaus.groovy.antlr.AntlrASTProcessor;
import org.codehaus.groovy.antlr.LineColumn;
import org.codehaus.groovy.antlr.SourceBuffer;
import org.codehaus.groovy.antlr.UnicodeEscapingReader;
import org.codehaus.groovy.antlr.java.Java2GroovyConverter;
import org.codehaus.groovy.antlr.java.JavaLexer;
import org.codehaus.groovy.antlr.java.JavaRecognizer;
import org.codehaus.groovy.antlr.parser.GroovyLexer;
import org.codehaus.groovy.antlr.parser.GroovyRecognizer;
import org.codehaus.groovy.antlr.parser.GroovyTokenTypes;
import org.codehaus.groovy.antlr.treewalker.PreOrderTraversal;
import org.codehaus.groovy.antlr.treewalker.Visitor;
import org.codehaus.groovy.control.ResolveVisitor;
import org.codehaus.mojo.groovy.runtime.support.util.SourceType;

/**
 * ???
 *
 * @version $Id$
 * @author <a href="mailto:jason@planet57.com">Jason Dillon</a>
 */
public class QDoxStubTranslator
    implements GroovyTokenTypes
{
    private static final Pattern JAVADOCS_PATTERN = Pattern.compile("(?s).*/\\*\\*(.*?)\\*/[^\\*/}]*$");

    private static final Type OBJECT = new Type(Object.class.getName());

    private SourceBuffer sourceBuffer;

    private String[] tokenNames;

    private AST lastNode;

    private JavaSource javaSource;

    private JavaClass javaClass;

    public JavaSource translate(final URL input) throws Exception {
        assert input != null;

        resetState();

        SourceType type = SourceType.forURL(input);

        javaSource.setURL(input);

        Reader reader = new BufferedReader(new InputStreamReader(input.openStream()));

        try {
            return parse(reader, type);
        }
        finally {
            reader.close();
        }
    }

    public int write(final URL input, final File outputDir) throws Exception {
        assert input != null;
        assert outputDir != null;

        JavaClass[] classes = translate(input).getClasses();

        for (int i=0; i<classes.length; i++) {
            PrintWriter out = createWriter(classes[i], outputDir);

            try {
                render(classes[i], out);
            }
            finally {
                out.close();
            }
        }

        return classes.length;
    }

    private PrintWriter createWriter(final JavaClass type, final File outputDir) throws IOException {
        assert type != null;
        assert outputDir != null;

        StringBuffer buff = new StringBuffer();

        String pkg = type.getPackage();

        if (pkg != null) {
            buff.append(pkg.replace('.', '/'));
            buff.append("/");
        }

        buff.append(type.getName());
        buff.append(SourceType.JAVA_EXT);

        File outputFile = new File(outputDir, buff.toString());

        outputFile.getParentFile().mkdirs();

        return new PrintWriter(new BufferedWriter(new FileWriter(outputFile)));
    }

    private void render(final JavaClass type, final PrintWriter out) {
        assert type != null;
        assert out != null;

        out.println("//");
        out.println("// Generated by " + getClass().getName() + " on " + new Date());
        out.println("//");
        out.println();

        String pkg = type.getSource().getPackage();

        if (pkg != null) {
            out.println("package " + pkg + ";");
            out.println();
        }

        String[] imports = type.getSource().getImports();
        for (int j=0; j<imports.length; j++) {
            out.println("import " + imports[j] + ";");
        }
        if (imports.length > 0) {
            out.println();
        }

        out.write(type.toString());
        out.println();

        out.flush();
    }

    private void resetState() {
        javaSource = new JavaSource();
        sourceBuffer = new SourceBuffer();
        tokenNames = null;
        lastNode = null;
        javaClass = null;
    }

    private JavaSource parse(final Reader reader, final SourceType type) throws Exception {
        assert reader != null;

        AST node;
        UnicodeEscapingReader unicodeReader = new UnicodeEscapingReader(reader, sourceBuffer);

        switch (type.code) {
            case SourceType.GROOVY_CODE: {
                GroovyLexer lexer = new GroovyLexer(unicodeReader);
                unicodeReader.setLexer(lexer);

                GroovyRecognizer parser = GroovyRecognizer.make(lexer);
                parser.setSourceBuffer(sourceBuffer);
                tokenNames = parser.getTokenNames();

                parser.compilationUnit();
                node = parser.getAST();
                break;
            }

            case SourceType.JAVA_CODE: {
                JavaLexer lexer = new JavaLexer(unicodeReader);
                unicodeReader.setLexer(lexer);

                JavaRecognizer parser = JavaRecognizer.make(lexer);
                parser.setSourceBuffer(sourceBuffer);
                tokenNames = parser.getTokenNames();

                parser.compilationUnit();
                node = parser.getAST();

                // Convert the Java AST into Groovy AST
                Visitor converter = new Java2GroovyConverter(tokenNames);
                AntlrASTProcessor processor = new PreOrderTraversal(converter);
                processor.process(node);
                break;
            }

            default:
                throw new IllegalArgumentException("Invalid source type: " + type);
        }

        addDefaultImports(javaSource);

        process(node);

        addSourceTypeTags(javaSource, type);

        return javaSource;
    }

    // ResolveVisitor does not have this accessible in Groovy 1.0
    private static final String[] DEFAULT_IMPORTS = {
        "java.lang.",
        "java.io.",
        "java.net.",
        "java.util.",
        "groovy.lang.",
        "groovy.util.",
    };

    private void addDefaultImports(final JavaSource javaSource) {
        assert javaSource != null;

        for (int i=0; i<DEFAULT_IMPORTS.length; i++) {
            javaSource.addImport(DEFAULT_IMPORTS[i] + "*");
        }
    }

    private void addSourceTypeTags(final JavaSource source, final SourceType type) {
        assert source != null;
        assert type != null;

        JavaClass[] classes = source.getClasses();

        for (int i=0; i<classes.length; i++) {
            DocletTag[] orig = classes[i].getTags();

            List tags = new ArrayList(Arrays.asList(orig));
            tags.add(new DefaultDocletTag(SourceType.SOURCE_TYPE_TAG, type.toString()));

            classes[i].setTags(tags);
        }
    }

    //
    // Processing
    //

    private void process(AST node) {
        assert node != null;

        while (node != null) {
            int type = node.getType();
            switch (type) {
                case PACKAGE_DEF:
                    packageDef(node);
                    break;

                case STATIC_IMPORT:
                case IMPORT:
                    importDef(node);
                    break;

                case CLASS_DEF:
                    classDef(node);
                    break;

                case INTERFACE_DEF:
                    interfaceDef(node);
                    break;

                case METHOD_DEF:
                    methodDef(node);
                    break;

                case ENUM_DEF:
                    throw new Error("Enum not supported");

                default:
                    unknownAST(node);
                    break;
            }

            node = node.getNextSibling();
        }
    }

    private void packageDef(final AST packageDef) {
        AST node = packageDef.getFirstChild();
        if (isType(ANNOTATIONS, node)) {
            node = node.getNextSibling();
        }
        String name = qualifiedName(node);
        javaSource.setPackage(name);
    }

    private void importDef(final AST importNode) {
        boolean isStatic = importNode.getType() == STATIC_IMPORT;

        if (isStatic) {
            throw new Error("Static import is not supported");
        }

        AST node = importNode.getFirstChild();

        if (isType(LITERAL_as, node)) {
            throw new Error("Import alias not supported");
        }

        if (node.getNumberOfChildren() == 0) {
            String name = identifier(node);
            // import is like "import Foo"
            javaSource.addImport(name);
            return;
        }

        AST packageNode = node.getFirstChild();
        String packageName = qualifiedName(packageNode);
        AST nameNode = packageNode.getNextSibling();

        if (isType(STAR, nameNode)) {
            javaSource.addImport(packageName + ".*");
        }
        else {
            String name = identifier(nameNode);
            // import is like "import foo.Bar"
            javaSource.addImport(packageName + "." + name);
        }
    }

    private void interfaceDef(final AST classDef) {
        AST node = classDef.getFirstChild();

        Set modifiers = null;
        if (isType(MODIFIERS, node)) {
            modifiers = modifiers(node);
            node = node.getNextSibling();
        }
        if (modifiers == null) {
            modifiers = new HashSet();
        }
        if (!modifiers.contains("public") && !modifiers.contains("private") && !modifiers.contains("protected")) {
            modifiers.add("public");
        }

        String name = identifier(node);
        node = node.getNextSibling();

        Type[] interfaces = {};
        if (isType(EXTENDS_CLAUSE, node)) {
            interfaces = interfaces(node);
            node = node.getNextSibling();
        }

        javaClass = new JavaClass(name);
        javaClass.setInterface(true);

        addJavaDocs(javaClass, classDef);

        setModifers(javaClass, modifiers);

        if (interfaces.length > 0) {
            javaClass.setImplementz(interfaces);
        }

        assertNodeType(OBJBLOCK, node);
        objectBlock(node);

        javaSource.addClass(javaClass);
    }

    private void classDef(final AST classDef) {
        AST node = classDef.getFirstChild();

        Set modifiers = null;
        if (isType(MODIFIERS, node)) {
            modifiers = modifiers(node);
            node = node.getNextSibling();
        }
        if (modifiers == null) {
            modifiers = new HashSet();
        }
        if (!modifiers.contains("public") && !modifiers.contains("private") && !modifiers.contains("protected")) {
            modifiers.add("public");
        }

        String name = identifier(node);
        node = node.getNextSibling();

        if (isType(TYPE_PARAMETERS,node)) {
            throw new Error("Generics not supported");
        }

        Type superClass = null;
        if (isType(EXTENDS_CLAUSE, node)) {
            superClass = makeType(node);
            node = node.getNextSibling();
        }

        Type[] interfaces = {};
        if (isType(IMPLEMENTS_CLAUSE, node)) {
            interfaces = interfaces(node);
            node = node.getNextSibling();
        }

        javaClass = new JavaClass(name);

        addJavaDocs(javaClass, classDef);

        setModifers(javaClass, modifiers);

        if (superClass != null) {
            javaClass.setSuperClass(superClass);
        }

        if (interfaces.length > 0) {
            javaClass.setImplementz(interfaces);
        }

        assertNodeType(OBJBLOCK, node);
        objectBlock(node);

        javaSource.addClass(javaClass);
    }

    private void objectBlock(final AST objectBlock) {
        for (AST node = objectBlock.getFirstChild(); node != null; node = node.getNextSibling()) {
            int type = node.getType();
            switch (type) {
                case OBJBLOCK:
                    objectBlock(node);
                    break;

                case METHOD_DEF:
                    methodDef(node);
                    break;

                case CTOR_IDENT:
                    constructorDef(node);
                    break;

                case VARIABLE_DEF:
                    fieldDef(node);
                    break;

                case STATIC_INIT:
                case INSTANCE_INIT:
                    // Ignore
                    break;

                case ENUM_DEF:
                case ENUM_CONSTANT_DEF:
                    throw new Error("Enum not supported");

                default:
                    unknownAST(node);
            }
        }
    }

    private void throwsList(final AST node, final List list) {
        String name;

        if (isType(DOT, node)) {
            name = qualifiedName(node);
        }
        else {
            name = identifier(node);
        }

        list.add(new Type(name));

        AST next = node.getNextSibling();

        if (next != null) {
            throwsList(next, list);
        }
    }

    private void methodDef(final AST methodDef) {
        AST node = methodDef.getFirstChild();

        if (isType(TYPE_PARAMETERS, node)) {
            throw new Error("Generics not supported");
        }

        Set modifiers = null;
        if (isType(MODIFIERS, node)) {
            modifiers = modifiers(node);
            node = node.getNextSibling();
        }
        if (modifiers == null) {
            modifiers = new HashSet();
        }
        if (!javaClass.isInterface() && !modifiers.contains("public") && !modifiers.contains("private") && !modifiers.contains("protected")) {
            modifiers.add("public");
        }

        Type returnType = null;
        if (isType(TYPE, node)) {
            returnType = makeType(node);
            node = node.getNextSibling();
        }

        String name = identifier(node);
        node = node.getNextSibling();

        assertNodeType(PARAMETERS, node);
        JavaParameter[] parameters = parameters(node);
        node = node.getNextSibling();

        Type[] exceptions = null;
        if (isType(LITERAL_throws, node)) {
            AST throwsNode = node.getFirstChild();
            List list = new ArrayList();
            throwsList(throwsNode, list);
            exceptions = (Type[]) list.toArray(new Type[list.size()]);
            node = node.getNextSibling();
        }

        // Skip body when not interface or abstract method
        if (!javaClass.isInterface() && !modifiers.contains("abstract")) {
            assertNodeType(SLIST, node);
            // noinspection UnusedAssignment
            node = node.getNextSibling();
        }

        JavaMethod method = new JavaMethod(returnType, name);

        addJavaDocs(method, methodDef);

        setModifers(method, modifiers);

        if (parameters != null) {
            method.setParameters(parameters);
        }

        if (exceptions != null) {
            method.setExceptions(exceptions);
        }

        // Write out a body unless its an interface or abstract method
        if (!javaClass.isInterface() && !modifiers.contains("abstract")) {
            method.setSourceCode("{ throw new Error(); }");
        }

        javaClass.addMethod(method);
    }

    private void constructorDef(final AST constructorDef) {
        AST node = constructorDef.getFirstChild();

        Set modifiers = null;
        if (isType(MODIFIERS, node)) {
            modifiers = modifiers(node);
            node = node.getNextSibling();
        }
        if (modifiers == null) {
            modifiers = new HashSet();
        }
        if (!modifiers.contains("public") && !modifiers.contains("private") && !modifiers.contains("protected")) {
            modifiers.add("public");
        }

        assertNodeType(PARAMETERS, node);
        JavaParameter[] parameters = parameters(node);
        node = node.getNextSibling();

        Type[] exceptions = null;
        if (isType(LITERAL_throws, node)) {
            AST throwsNode = node.getFirstChild();
            List list = new ArrayList();
            throwsList(throwsNode, list);
            exceptions = (Type[]) list.toArray(exceptions);
            node = node.getNextSibling();
        }

        // Skip the ctor body
        assertNodeType(SLIST, node);
        // noinspection UnusedAssignment
        node = node.getNextSibling();

        JavaMethod method = new JavaMethod(javaClass.getName());
        method.setConstructor(true);

        addJavaDocs(method, constructorDef);

        setModifers(method, modifiers);

        if (parameters != null) {
            method.setParameters(parameters);
        }

        if (exceptions != null) {
            method.setExceptions(exceptions);
        }

        //
        // TODO: May need some magic to invoke super()
        //

        method.setSourceCode("{ throw new Error(); }");

        javaClass.addMethod(method);
    }

    private void fieldDef(final AST fieldDef) {
        AST node = fieldDef.getFirstChild();

        Set modifiers = null;
        if (isType(MODIFIERS, node)) {
            modifiers = modifiers(node);
            node = node.getNextSibling();
        }
        if (modifiers == null) {
            modifiers = new HashSet();
        }
        if (!javaClass.isInterface() && !modifiers.contains("public") && !modifiers.contains("private") && !modifiers.contains("protected")) {
            modifiers.add("public");
        }

        Type type = OBJECT;
        if (isType(TYPE, node)) {
            type = makeType(node);
            node = node.getNextSibling();
        }

        String name = identifier(node);
        // noinspection UnusedAssignment
        node = node.getNextSibling();

        String initialValue = null;
        if (node != null) {
            assertNodeType(ASSIGN, node);

            if (type.isPrimitive()) {
                if (type.getValue().equals("boolean")) {
                    initialValue = "false";
                }
                else {
                    initialValue = "(" + type.getValue() + ") 0";
                }
            }
            else {
                initialValue = "null";
            }
        }

        JavaField field = new JavaField(type, name);

        addJavaDocs(field, fieldDef);

        setModifers(field, modifiers);

        if (initialValue != null) {
            field.setInitializationExpression(initialValue);
        }

        javaClass.addField(field);
    }

    private Type[] interfaces(final AST node) {
        List list = new ArrayList();

        for (AST implementNode = node.getFirstChild(); implementNode != null; implementNode = implementNode.getNextSibling()) {
            list.add(makeType(implementNode));
        }

        return (Type[]) list.toArray(new Type[list.size()]);
    }

    private JavaParameter[] parameters(final AST parametersNode) {
        AST node = parametersNode.getFirstChild();

        if (node == null) {
            if (isType(IMPLICIT_PARAMETERS, parametersNode)) {
                return JavaParameter.EMPTY_ARRAY;
            }

            return null;
        }

        List list = new ArrayList();

        do {
            list.add(parameter(node));
            node = node.getNextSibling();
        }
        while (node != null);

        return (JavaParameter[]) list.toArray(new JavaParameter[list.size()]);
    }

    private JavaParameter parameter(final AST paramNode) {
        AST node = paramNode.getFirstChild();

        // Qdox doesn't have modifers for parameters, so skip them
        if (isType(MODIFIERS, node)) {
            node = node.getNextSibling();
        }

        Type type = OBJECT;
        if (isType(TYPE, node)) {
            type = makeType(node);
            node = node.getNextSibling();
        }

        String name = identifier(node);
        // noinspection UnusedAssignment
        node = node.getNextSibling();

        return new JavaParameter(type, name);
    }

    private void setModifers(final AbstractJavaEntity entity, final Set modifiers) {
        if (modifiers != null) {
            entity.setModifiers((String[]) modifiers.toArray(new String[modifiers.size()]));
        }
    }

    private Set modifiers(final AST modifierNode) {
        assertNodeType(MODIFIERS, modifierNode);

        Set modifiers = new HashSet();

        for (AST node = modifierNode.getFirstChild(); node != null; node = node.getNextSibling()) {
            int type = node.getType();

            switch (type) {
                case STRICTFP:
                case STATIC_IMPORT:
                case ANNOTATION:
                    // ignore
                    break;

                case LITERAL_private:
                    modifiers.add("private");
                    break;

                case LITERAL_protected:
                    modifiers.add("protected");
                    break;

                case LITERAL_public:
                    modifiers.add("public");
                    break;

                case ABSTRACT:
                    modifiers.add("abstract");
                    break;

                case FINAL:
                    modifiers.add("final");
                    break;

                case LITERAL_native:
                    modifiers.add("native");
                    break;

                case LITERAL_static:
                    modifiers.add("static");
                    break;

                case LITERAL_synchronized:
                    modifiers.add("synchronized");
                    break;

                case LITERAL_transient:
                    modifiers.add("transient");
                    break;

                case LITERAL_volatile:
                    modifiers.add("volatile");
                    break;

                default:
                    unknownAST(node);
            }
        }

        return modifiers;
    }

    //
    // Parsing Helpers
    //

    private String getTokenName(final int token) {
        return tokenNames[token];
    }

    private String getTokenName(final AST node) {
        if (node == null) {
            return "null";
        }
        return getTokenName(node.getType());
    }

    private void assertNodeType(final int type, final AST node) {
        if (node == null) {
            throw new ASTRuntimeException(node, "No child node available in AST when expecting type: " + getTokenName(type));
        }
        if (node.getType() != type) {
            throw new ASTRuntimeException(node, "Unexpected node type: " + getTokenName(node) + " found when expecting type: " + getTokenName(type));
        }
    }

    private boolean isType(int typeCode, AST node) {
        return node != null && node.getType() == typeCode;
    }

    private String qualifiedName(final AST qualifiedNameNode) {
        assert qualifiedNameNode != null;

        if (isType(IDENT, qualifiedNameNode)) {
            return qualifiedNameNode.getText();
        }

        if (isType(DOT, qualifiedNameNode)) {
            AST node = qualifiedNameNode.getFirstChild();
            StringBuffer buffer = new StringBuffer();
            boolean first = true;

            for (; node != null; node = node.getNextSibling()) {
                if (first) {
                    first = false;
                }
                else {
                    buffer.append(".");
                }
                buffer.append(qualifiedName(node));
            }
            return buffer.toString();
        }
        else {
            return qualifiedNameNode.getText();
        }
    }

    private String identifier(final AST node) {
        assert node != null;
        assertNodeType(IDENT, node);

        return node.getText();
    }

    private String cleanseJavaDocs(final String javadocs) {
        StringBuffer buff = new StringBuffer();

        String[] lines = javadocs.split("\n");

        for (int i=0; i<lines.length; i++) {
            String line = lines[i].trim();

            if (line.startsWith("*")) {
                line = line.substring(1, line.length()).trim();
            }

            buff.append(line);

            if (i + 1 < lines.length) {
                buff.append("\n");
            }
        }

        return buff.toString();
    }

    private void addJavaDocs(final AbstractJavaEntity entity, final AST node) {
        String javadocs = javadocs(node);

        if (javadocs != null) {
            // First clean up the docs
            javadocs = cleanseJavaDocs(javadocs);

            // Then render a synthetic class to parse out the comment and tags
            StringWriter writer = new StringWriter();
            PrintWriter out = new PrintWriter(writer);

            out.println("/**");
            out.println(javadocs);
            out.println(" */");
            out.println("class Dummy {}");
            out.flush();

            StringReader reader = new StringReader(writer.getBuffer().toString());

            JavaDocBuilder builder = new JavaDocBuilder();
            builder.addSource(reader);

            JavaClass[] classes = builder.getClasses();
            String comment = classes[0].getComment();
            DocletTag[] tags = classes[0].getTags();

            if (comment != null) {
                entity.setComment(comment);
            }

            if (tags != null && tags.length > 0) {
                List list = new ArrayList(tags.length);

                list.addAll(Arrays.asList(tags));

                entity.setTags(list);
            }
        }
    }

    private String javadocs(final AST node) {
        assert node != null;

        // Figure out where we should start looking
        LineColumn startAt;
        if (lastNode != null) {
            startAt = new LineColumn(lastNode.getLine(), lastNode.getColumn());
        }
        else {
            startAt = new LineColumn(1,1);
        }
        LineColumn stopAt = new LineColumn(node.getLine(), node.getColumn());

        // Remember where we last looked
        lastNode = node;

        String text = sourceBuffer.getSnippet(startAt, stopAt);

        /*
        System.out.println();
        System.out.println("----8<----");
        System.out.println(text);
        System.out.println("---->8----");
        System.out.println();
        */

        String javadocs = null;

        if (text != null) {
            Matcher m = JAVADOCS_PATTERN.matcher(text);
            if (m.matches()) {
                int lastGroupIndex = m.groupCount();
                if (lastGroupIndex > 0) {
                    javadocs = m.group(lastGroupIndex).trim();

                    /*
                    System.out.println();
                    System.out.println("----8<----");
                    System.out.println(javadocs);
                    System.out.println("---->8----");
                    System.out.println();
                    */
                }
            }
        }

        return javadocs;
    }

    private Type makeType(final AST typeNode) {
        AST node = typeNode.getFirstChild();

        Type type = OBJECT;

        if (node != null) {
            if (isType(INDEX_OP, node)) {
                type = new Type(qualifiedName(node.getFirstChild()), 1);
            }
            else if (isType(ARRAY_DECLARATOR, node)) {
                type = new Type(qualifiedName(node.getFirstChild()), 1);
            }
            else {
                String name = qualifiedName(node);

                if (name.equals("void")) {
                    type = Type.VOID;
                }
                else {
                    type = new Type(name);
                }
            }
        }

        return type;
    }

    private void unknownAST(AST node) {
        throw new Error("Unknown AST: " + getTokenName(node));
    }

    private void dumpTree(AST ast) {
        dumpTree(ast, "");
    }

    private void dumpTree(AST ast, String indent) {
        dump(ast);

        for (AST node = ast.getFirstChild(); node != null; node = node.getNextSibling()) {
            if (node.getNumberOfChildren() > 0) {
                dumpTree(node, indent + "    ");
            }
            else {
                dump(node, indent + "    ");
            }
        }
    }

    private void dump(AST node) {
        dump(node, "");
    }

    private void dump(AST node, String indent) {
        System.out.println(indent + "Node: " + node + " Type: " + getTokenName(node) + "(" + node.getType() + ") Text: " + node.getText());
    }
}