 ------
 Executing Groovy
 ------
 ------
 $Id$

~~
~~ Copyright (C) 2006-2007 the original author or authors.
~~
~~ Licensed under the Apache License, Version 2.0 (the "License");
~~ you may not use this file except in compliance with the License.
~~ You may obtain a copy of the License at
~~
~~     http://www.apache.org/licenses/LICENSE-2.0
~~
~~ Unless required by applicable law or agreed to in writing, software
~~ distributed under the License is distributed on an "AS IS" BASIS,
~~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~~ See the License for the specific language governing permissions and
~~ limitations under the License.
~~ 

Executing Groovy

 <<NOTE:>> The examples below, unless otherwise specified, all assume that the
 Maven build is invoked with a life-cycle phase:

+----------+
mvn install
+----------+

 Due to the use of executions configurations, invoking the named goals from the 
 command-line will fail to function correctly.

* Default Variables

 By default a few variables are bound into the scripts environment:
 
  * <<<project>>> - The maven project, with auto-resolving properties.

  * <<<pom>>> - Alias for <<<project>>>

  * <<<log>>> - The maven plugin logger
  
  * <<<ant>>> - An AntBuilder instance for easy access to Ant tasks.
  
  * <<<fail()>>> - A helper to throw MojoExecutionException

* Execute an Inline Groovy Script

+----------+
<plugin>
    <groupId>org.codehaus.mojo.groovy</groupId>
    <artifactId>groovy-maven-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <source>
                    if (project.packaging != "pom") {
                        log.info("Copying some stuff...")

                        def dir = "${project.basedir}/target/classes/META-INF"

                        ant.mkdir(dir: dir)
                        ant.copy(todir: dir) {
                            fileset(dir: "${project.basedir}") {
                                include(name: "LICENSE.txt")
                                include(name: "NOTICE.txt")
                            }
                        }
                    }
                </source>
            </configuration>
        </execution>
    </executions>
</plugin>
+----------+

* Execute a Local Groovy Script

+----------+
<plugin>
    <groupId>org.codehaus.mojo.groovy</groupId>
    <artifactId>groovy-maven-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <source>${pom.basedir}/src/main/script/myscript.groovy</source>
            </configuration>
        </execution>
    </executions>
</plugin>
+----------+

* Execute a Remote Groovy Script

+----------+
<plugin>
    <groupId>org.codehaus.mojo.groovy</groupId>
    <artifactId>groovy-maven-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <source>http://mydomain.com/myscript.groovy</source>
            </configuration>
        </execution>
    </executions>
</plugin>
+----------+

* Using Java Classes

 Scripts can use Java classes.  To include custom classes to be available to the script define
 a <<<classpath>>> which contains additional artifacts to included in the scripts classloader.

 This is the preferred mechanism to extend a scripts classpath instead of adding dependencies to
 the plugin, which may cause problems if the classpath needs to be different on more than
 one plugin execution or when it differs between usage in more than one module in a multi-module
 build.

 Artifact definitions will pick up missing details from the pom's <<<dependencyManagement>>> section.

~~
~~ NOTE: This is a bad example, since commons-lang is already on the plugins classpath
~~

+----------+
<plugin>
    <groupId>org.codehaus.mojo.groovy</groupId>
    <artifactId>groovy-maven-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <classpath>
                    <element>
                        <groupId>commons-lang</groupId>
                        <artifactId>commons-lang</groupId>
                    </element>
                </classpath>
                <source>
                    import org.apache.commons.lang.SystemUtils
                    if (SystemUtils.IS_OS_WINDOWS) {
                        println("Go buy a Mac!")
                    }
                </source>
            </configuration>
        </execution>
    </executions>
</plugin>
+----------+

* Using Groovy Classes

 By setting the <<<scriptpath>>> you can load additional Groovy classes.

 For example if you have a class named <<<Helper>>> defined in a file named
 <<<$\{pom.basedir}/src/main/script/Helper.groovy>>> your scripts can use that class:

+----------+
<plugin>
    <groupId>org.groovy.mojo.groovy</groupId>
    <artifactId>groovy-maven-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <scriptpath>
                    <element>${pom.basedir}/src/main/script</element>
                </scriptpath>
                <source>
                    import Helper
                    Helper.callSomeStatic()
                </source>
            </configuration>
        </execution>
    </executions>
</plugin>
+----------+

* Custom Properties

 By setting <<<properties>>> additional project properties can be added for an execution.
 
 Properties will automatically resolve when accessed.  This means that if you have defined
 a property with a value of <<<$\{session}>>> that when you access it from your
 script, the returned value will be the MavenSession instance, just as one would
 expect when using <<<@parameter expression="$\{session}">>> in a Mojo annotation.  Though
 as noted below, default values are handled slightly differently than what is done
 currently for Mojo annotations.
 
 <<NOTE:>> Property expressions are <<not>> GStrings... so you need to use <<<$\{...}>>>
 syntax for them, <<<$...>>> will <<not>> work.
 
 Because of this property resolution, the value of a property might not be a String
 as one might expect when talking about normal Java properties.  But, just for us
 Groovy doesn't really care what the type is.

+----------+
<plugin>
    <groupId>org.codehaus.mojo.groovy</groupId>
    <artifactId>groovy-maven-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <properties>
                    <hello>world</hello>
                </properties>
                <source>
                    println project.properties['hello']
                    
                    // or if you prefer, these work just the same:
                    // println project.properties.hello
                    // println project.properties.get('hello')
                    // println project.properties.getProperty('hello')
                </source>
            </configuration>
        </execution>
    </executions>
</plugin>
+----------+

 By setting <<<defaults>>> additional project properties can be added for an execution
 which will be used only if the project or system does not override.

+----------+
<plugin>
    <groupId>org.codehaus.mojo.groovy</groupId>
    <artifactId>groovy-maven-plugin</artifactId>
    <executions>
        <execution>
            <phase>generate-resources</phase>
            <goals>
                <goal>execute</goal>
            </goals>
            <configuration>
                <defaults>
                    <hello>world</hello>
                </defaults>
                <source>
                    println project.properties['hello']
                </source>
            </configuration>
        </execution>
    </executions>
</plugin>
+----------+

 To provide a system override:

+----------+
mvn -Dhello=jason
+----------+

** Using <<<fail()>>>

 Sometimes executed Groovy scripts need to fail the build.  To do so with out causing
 evil stack traces or assert experssions to get spat out, you need to throw a
 <<<MojoExecutionException>>>.  To help make this a little bit easier there is a <<<fail()>>>
 closure bound the the default namespace for the executed script.

 Failing with a simple string:

+----+
fail("That ain't no woman! It's a man, man!")
+----+

 Failing with an exception detail:

+----+
try {
    ....
}
catch (Exception e) {
    fail(e)
}
+----+

 Failing with an exception detail and a message:

+----+
try {
    ....
}
catch (Exception e) {
    fail("She's the village bicycle! Everybody's had a ride.", e)
}
+----+
